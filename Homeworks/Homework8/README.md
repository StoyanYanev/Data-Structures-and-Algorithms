**Задача 1. (AVL)**

Довършете балансираното AVL дърво като имплементирате следните операции

1. добавяне на елемент
2. премахване на елемент

**Забранено е използването на stl::map**

**Input Format**

При add ако числото вече съществува, да изписва &quot;X already added&quot; и нов ред след това (на мястото на X да се изписва самото подадено число)

При remove ако числото не съществува, да изписва &quot;X not found to remove&quot; и нов ред след това (на мястото на X да се изписва самото подадено число)

**Constraints**

1 <= N <= 100 000

int.MIN_VALUE <= number <= int.MAX_VALUE


**Output Format**

При операция contains изпишете &quot;yes&quot; или &quot;no&quot; в зависимост от това дали даденото число се съдържа в дървото.

При операция print изпишете текущото състояние на дървото във формат Ляво-Корен-Дясно с разстояние между елементите.

Note! cout << fixed; винаги връща до 6 символа след десетичната запетая.

**Sample Input 0**

7

add 58

add 98

contains 58

add 52

contains 23

add 23

print

**Sample Output 0**

yes

no

23.000000 52.000000 58.000000 98.000000

**Sample Input 1**

16

add 8.43

add 5.83

add 7.66

add 1.92

remove 7.66

add 4.47

add -2.76

contains 7.23

add -1.64

remove 5.49

add 4.66

add 3.04

add 4.47

contains 8.43

add 7.34

print

**Sample Output 1**

no

5.490000 not found to remove

4.470000 already added

yes

-2.760000 -1.640000 1.920000 3.040000 4.470000 4.660000 5.830000 7.340000 8.430000

**Задача 2. (VolleyballPlayers)**

Учениците от ж.к. Лозенец искат да играят в тазгодишния турнир по волейбол. Естествено само най-добрите N+1 са поканени да участват. Едно от децата на организаторите на турнира вече е записано в екипа. Останалите N обаче имат условие - не искат да участват в екипа ако не участват и най-добрите им приятели.

Всички ученици имат свой номер, по който да ги разпознаем. Номерата нямат определена подредба и дори могат да са отрицателни. Всеки ученик знае номерата на неговите един или повече най-добри приятели, присъствието на всеки от които ще го мотивира да се запише. Това приятелство е едностранно - ако ученик 1 има 2 за най-добър приятел, не е задължително 2 да има 1 за най-добър приятел.

Знаейки кой ученик кого смята за най-добър приятел, намерете броя на финалния състав на екипа.

**Input Format**

На първия ред получавате число m - номера на първия участник. На втория ред получавате число N. На следващите N реда получавате двойки числа разделени с разстояние. Първото от тях отговаря на номера на най-добрия приятел, който трябва да е част от екипа. Ако е така, тогава втория ученик (представляван от второто число) се включва към екипа. На всеки ред се интересувате само от текущия състав на екипа, независимо какво може да следва нататък - ако най-добрият приятел 2 на съответния ученик 1 не е част от отбора, когато 1 го потърси, 1 си тръгва разочарован.

**Constraints**

1 <= N <= 250 000

Номерата на учениците са в интервала [int.MIN_VALUE, int.MAX_VALUE]

**Output Format**

На единствения ред от изхода изпишете броя на учениците в екипа.

**Sample Input 0**

18

5

21 10

18 21

21 14

15 75

75 3

**Sample Output 0**

3

**Explanation 0**

18, 21, 14

**Sample Input 1**

543

8

-123 14

25 2

543 -831

543 29

-831 29

29 25

-999 3

543 12852

**Sample Output 1**

5

**Explanation 1**

543, -831, 29, 25, 12852
