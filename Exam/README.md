**Задача 1.** **(BinaryTreeFirstPart)**

Напишете следните функции за двоично наредено дърво:

void аdd(int X) - добавя елемент в двоично наредено дърво(ако елемента вече съществува в дървото то дървото не се променя). Не принтира нищо на стандартният изход.

void print() - извежда на стандартният изход дървото в последователност корен-ляво-дясно разделена с интервали

**Input Format**

N - брой операции които ще бъдат подадени

Следват N операции всяка от която на нов ред( операцията се дава с името си и ако има входен параметър например: add число, print)

**Constraints**

1 < N < 200 000

**Output Format**

На стандартният изход се очаква да се принтира поредица от числа спрямо изхода от изпълнените операции. (Всичко се принтира на един ред, като всички числа са разделени с интервали)

**Sample Input 0**

5

add 2

add 5

add 5

add 1

print

**Sample Output 0**

2 1 5



**Задача 2.** **(BinaryTreeSecondPart)**

Използвайте вече написаните функции add и print и добавете следните нови функции:

void remove(int X)- ако в дървото имаме елемент X го изтрива (запазвайки структурата наредено двоично дърво, **hint:** ако възела няма наследник просто се премахва, ако има само един наследник то той отива на негово място, а ако има два наследника тогава се търси най-малкият по-голям от него). Не принтира нищо на стандартният изход.

void print_odd_layers() - принтира елементите на дървото от нечетните му нива започвайки от корена и продължавайки с 3 ниво, 5 ниво и т.н. (елементите от четните нива се прескачат)

**Input Format**

N - брой на операциите Следват имената на операциите като аргументите са разделени с интервал

**Constraints**

1 < N < 200 000

**Output Format**

Изход спрямо изпълнените операции

**Sample Input 0**

5

add 2

add 2

add 1

remove 2

print

**Sample Output 0**

1

**Sample Input 1**

8

add 1

add 2

add 4

add 6

add 7

add 5

print\_odd\_layers

print

**Sample Output 1**

1 4 5 7 1 2 4 6 5 7

**Задача 3.** **(DundeeTheCrocodile)**

Дадени са ви две изречения A и B.

Думите в изреченията са  **само с малки букви**  и всяка дума е разделена с точно един знак за празен символ.

Освен малки букви и празно място между тях,  **други символи няма да същестуват като вход**.

Една дума ще наричаме 'Крокодил от Австралия'  **ако се среща точно един път в едно от изреченията и не се среща в другото изречение**.

От вас се иска да изведете по дума на нов ред всички такива думи които са 'Крокодил от Австралия'. Тъй като може да има много възможни наредби за изход,  **то първо сортирайте всички тези думи спрямо тяхната лексикографка наредба и след това ги отпечатайте, всяка на нов ред**.

Пример:

a b c

b a d

Двете думи които отговарят на условието са: d,c

Примерен Изход:

c

d

Пояснение:

d

c

Не е коректен отговор, защото трябва да изведете всяка дума на нов ред като започнем от лексикографски най-малката.

**Input Format**

Две изречения, всяко на нов ред

**Constraints**

Дължината на A и B не е по-голяма от 500 символа.

**Output Format**

Всички думи които отговарят на условието, като на всеки ред трябва да имате по една дума.

**Sample Input 0**

hello world

world bye

**Sample Output 0**

bye

hello

**Sample Input 1**

ha ha ha ha

not

**Sample Output 1**

not



**Задача 4.** **(DetectCycleInDirectedGraph)**

Даден е насочен граф с тегла по ребрата. Да се напише функция, която проверява дали има цикъл в графа.

**Input Format**

N - брой тестове следват N на брой тестове всеки от който има: V E - брой върхове и брой ребра xi yi wi - ребро между връх xi и връх yi с тегло wi

**Constraints**

1 < N < 20

1< V < 1000

**Output Format**

за всеки граф ако има цикъл се принтира true иначе falsе, резултатите се разделят с интервал.

**Sample Input 0**

2

3 5

3 1 4

2 3 4

3 2 2

1 3 2

2 1 1

3 5

1 3 1

1 2 4

2 3 3

3 1 3

3 2 4

**Sample Output 0**

true true
